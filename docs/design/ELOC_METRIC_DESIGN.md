# 研发效能度量升级方案：代码当量 (ELOC) 评估体系设计与实施

## 1. 方案概述 (Overview)

当前主流的基于“代码行数 (LOC)”的效能度量方式存在显著的公平性缺陷，易导致“刷行数”、忽视重构价值、文档缺失等负面工程行为。本方案旨在构建一套基于 **代码当量 (ELOC - Equivalent Lines of Code)** 的高级度量体系，通过多维加权算法，将物理代码行转化为更能反映真实工程价值的“逻辑当量”。

本方案采用 **“分层解析 + 价值加权”** 的技术路径，结合 AST (语法树) 分析与正则特征识别，对每一行代码变更进行智能分类与估值。

## 2. 目的与意义 (Purpose & Value)

1. **公平性 (Fairness)**: 消除语言差异（如 Java vs Python）、文件类型差异（如 JSON vs 核心逻辑）带来的统计偏差。
2. **导向性 (Guidance)**: 从机制上鼓励 **重构 (Refactoring)**、**写文档 (Documentation)** 和 **写测试 (Testing)**，抑制堆砌废代码。
3. **真实性 (Authenticity)**: 剔除自动生成代码、依赖锁文件等“伪贡献”，还原开发者的真实工作量。
4. **可维护性 (Maintainability)**: 通过给予“解释型注释”高权重，引导团队沉淀隐性知识，降低系统熵增。

## 3. 指标定义与算法模型 (Metrics & Algorithms)

### 3.1 核心公式

总当量 ($ELOC_{Total}$) 由三种变更行为的加权和构成：

$$ ELOC_{Total} = \sum (Line_i \times W_{Type} \times W_{Behavior} \times W_{Quality}) $$

其中：

* $W_{Type}$: 文件类型/内容类型权重。
* $W_{Behavior}$: 变更行为权重（增/删/改）。
* $W_{Quality}$: 质量修正系数（复杂度/Bug关联）。

---

### 3.2 详细指标权重体系

#### A. 行为维度权重 ($W_{Behavior}$)

| 行为类型 | 权重 | 设计逻辑 |
| :--- | :--- | :--- |
| **新增 (Addition)** | **1.0** | 基准分。正常的业务功能开发。 |
| **修改 (Modification)** | **1.5** | 修改现有代码通常涉及阅读理解上下文，风险更高，脑力成本大于单纯新增。 |
| **删除 (Deletion)** | **0.8 ~ 2.0** | **普通删除 (0.8)**: 常规清理。<br>**重构删除 (2.0)**: 如果检测到复杂度降低同时行数减少，给予高额奖励，鼓励“做减法”。 |

#### B. 内容类型权重 ($W_{Type}$) —— 核心差异化策略

我们将每一行变更的代码内容细分为以下 5 类进行区别计算：

| 内容分类 | 权重 | 识别特征 (算法识别) | 作用与价值 |
| :--- | :--- | :--- | :--- |
| **1. 核心逻辑 (Core Logic)** | **1.0** | `.py`, `.java`, `.go`, `.ts` 等源文件中的语句。 | 系统功能的直接载体，价值基准。 |
| **2. 解释型注释 ("Why" Comments)** | **1.2** | 包含 `TODO`, `FIXME`, `NOTE`, `HACK`, `Issue` 等关键词，或位于代码块内部的行级注释。 | **高价值资产**。将隐性知识显性化，防止踩坑，价值高于代码本身。 |
| **3. 文档型注释 (Docstrings)** | **0.8** | 类/函数的文档块 (`"""..."""`, `/**...*/`)。 | 提升代码可读性与API易用性，鼓励文档化。 |
| **4. 废弃代码 (Dead Code)** | **0.0** | 被注释掉的代码行 (正则匹配 `#.*score = 1` 等特征)。 | **技术债务**。不仅无价值，还干扰阅读，必须剔除。 |
| **5. 配置与数据 (Config/Data)** | **0.1** | `.json`, `.yaml`, `.xml`, `.html` (纯静态), `lockfiles`。 | 只有微小价值，防止通过格式化大量 JSON 刷数据。 |
| **6. 自动生成 (Generated)** | **0.0** | 文件头包含 `Generated by`, `Auto-generated` 或特定路径 `dist/`, `vendor/`。 | 毫无脑力成本，完全忽略。 |

#### C. 测试修正 ($W_{Test}$)

* **测试代码 (Test Code)**: 权重 **1.2**。
  * *识别*: 文件名匹配 `test_*.py`, `*_test.go`。
  * *价值*: 鼓励 TDD (测试驱动开发)，提升系统稳定性。

---

### 3.3 评分与反作弊策略

#### 1.  churning (代码搅动) 惩罚

* **定义**: 短期内（如 3 天）对同一段代码反复修改（Edit -> Revert -> Edit）。
* **策略**: 这里的 ELOC 贡献值 **衰减 50%**。说明开发者思路不清或测试不充分。

#### 2. 空格/格式化过滤

* **定义**: 仅涉及缩进、换行、尾部空格的变更。
* **策略**: **权重 0.0**。GitDiff 开启 `--ignore-space-change` 逻辑，完全忽略格式化带来的行数波动。

---

## 4. 技术实施方案 (Implementation Plan)

本方案将在现有的 `devops_collector` 架构中以 **Plugin** 形式落地。

### 4.1 架构设计

在 `plugins/gitlab` 模块中增加 `ELOCAnalyzer` 组件，介入 `Diff` 解析流程。

```mermaid
graph LR
    A[GitLab Webhook/API] --> B[GitLab Plugin]
    B --> C{Diff Fetcher}
    C --> D[ELOC Analyzer]
    D --> E[Line Classifier (正则/AST)]
    E --> F[Weight Calculator]
    F --> G[DB: commit_eloc_stats]
```

### 4.2 核心算法逻辑 (Python 伪代码)

```python
class ELOCAnalyzer:
    def analyze_commit(self, diff):
        total_eloc = 0
        
        for file in diff.files:
            # 1. 文件级过滤
            if self.is_generated(file.path): continue
            file_weight = self.get_file_weight(file.ext) # .py=1.0, .json=0.1
            
            for line in file.changes:
                # 2. 空白过滤
                if not line.content.strip(): continue
                
                # 3. 内容分类与加权
                line_weight = 1.0
                if self.is_comment(line):
                    if self.is_why_comment(line): 
                        line_weight = 1.2 # 解释型注释奖励
                    elif self.is_dead_code(line): 
                        line_weight = 0.0 # 废弃代码剔除
                    else: 
                        line_weight = 0.8 # 普通文档
                
                # 4. 行为加权
                behavior_weight = 1.0
                if line.type == 'add': behavior_weight = 1.0
                elif line.type == 'modify': behavior_weight = 1.5
                elif line.type == 'delete': behavior_weight = 0.8 # 默认删除
                
                # 5. 累加
                total_eloc += (1 * file_weight * line_weight * behavior_weight)
                
        return total_eloc
```

### 4.3 数据模型扩展

在数据库 `devops_db` 中新增表 `commit_metrics` 用于存储计算结果：

```sql
CREATE TABLE commit_metrics (
    commit_id VARCHAR(40) PRIMARY KEY,
    author_email VARCHAR(255),
    raw_additions INT,        -- 原始新增行数
    raw_deletions INT,        -- 原始删除行数
    eloc_score DECIMAL(10,2), -- 计算后的代码当量
    refactor_ratio DECIMAL(5,2), -- 重构比例 (Modified+Deleted / Total)
    comment_ratio DECIMAL(5,2),  -- 注释密度
    test_ratio DECIMAL(5,2)      -- 测试代码占比
);
```

## 5. 预期价值 (Expected Value)

1. **更公正的绩效参考**: 即使某位开发者只写了 200 行复杂的调度算法+详细注释，其 ELOC 可能高于写了 2000 行配置文件的开发者。
2. **工程文化引导**: 团队会发现写测试和文档能由“浪费时间”变为“刷分利器”，潜移默化地改善代码质量。
3. **技术债务可视化**: 通过追踪 Dead Code 的产生率和 Refactor 删除率，量化技术债务的积压与偿还情况。
